/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int __mingw_invalidParameterHandler(); // weak
int pre_c_init();
int pre_cpp_init();
int __tmainCRTStartup();
int WinMainCRTStartup();
int mainCRTStartup();
int __gcc_register_frame();
void __cdecl __gcc_deregister_frame(); // idb
void __noreturn err();
int VarInput(void);
int ProSolve(void);
void __cdecl __tcf_0(); // idb
int __cdecl __static_initialization_and_destruction_0(int a1, int a2);
int _GLOBAL__sub_I__Z3errSt16istream_iteratorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEcS3_iE();
// int __usercall std::basic_ios<char,std::char_traits<char>>::tie@<eax>(_DWORD *a1@<eax>, int a2@<edx>);
// int __stdcall std::operator<<<std::char_traits<char>>(_DWORD); weak
// _DWORD __cdecl std::ios_base::Init::~Init(std::ios_base::Init *this); idb
// _DWORD std::ios_base::Init::Init(std::ios_base::Init *this); idb
// _DWORD __cdecl std::ios_base::sync_with_stdio(std::ios_base *this, bool); idb
// _DWORD std::chrono::_V2::steady_clock::now(std::chrono::_V2::steady_clock *this); idb
// int __fastcall std::ostream::operator<<(_DWORD, _DWORD, _DWORD); weak
// int __fastcall std::ostream::operator<<(_DWORD); weak
// int __fastcall std::istream::operator>>(_DWORD, _DWORD); weak
_onexit_t __cdecl mingw_onexit(_onexit_t a1);
int __cdecl atexit(void (__cdecl *)());
void __cdecl __do_global_dtors(); // idb
int __do_global_ctors();
int __main();
int _setargv();
signed int __security_init_cookie();
void __cdecl __noreturn __report_gsfailure(int a1);
signed int __stdcall __dyn_tls_dtor(int a1, unsigned int a2, int a3);
signed int __stdcall __dyn_tls_init(int a1, int a2, int a3);
int __tlregdtor();
int (__cdecl *__cdecl __mingw_raise_matherr(int a1, int a2, double a3, double a4, double a5))(_DWORD);
int __cdecl __mingw_setusermatherr(int (__cdecl *a1)(_DWORD));
int __cdecl _matherr(struct _exception *);
void __cdecl fpreset();
int __cdecl _decode_pointer(int a1);
int __cdecl _encode_pointer(int a1);
// unsigned int __usercall mark_section_writable@<eax>(unsigned int result@<eax>);
void _pei386_runtime_relocator();
int __stdcall _gnu_exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo);
void __mingwthr_run_key_dtors_part_0();
signed int __cdecl ___w64_mingwthr_add_key_dtor(int a1, int a2);
int __cdecl ___w64_mingwthr_remove_key_dtor(int a1);
signed int __cdecl __mingw_TLScallback(int a1, unsigned int a2);
// bool __usercall _ValidateImageBase_part_0@<eax>(int a1@<eax>);
bool __cdecl _ValidateImageBase(_WORD *a1);
int __cdecl _FindPESection(int a1, unsigned int a2);
const char *__cdecl _FindPESectionByName(char *a1);
int __cdecl __mingw_GetSectionForAddress(int a1);
int __mingw_GetSectionCount();
int _FindPESectionExec();
signed int _GetPEImageBase();
unsigned int __cdecl _IsNonwritableInCurrentImage(int a1);
int __cdecl __mingw_enum_import_library_names(int a1);
int __deregister_frame_info(); // weak
// int __cdecl vfprintf(FILE *, const char *, va_list);
// int __cdecl strncmp(const char *, const char *, size_t);
// size_t __cdecl strlen(const char *);
// void (__cdecl *__cdecl signal(int, void (__cdecl *)(int)))(int);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl malloc(size_t);
// size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
// void __cdecl free(void *);
// int fprintf(FILE *, const char *, ...);
// void __cdecl __noreturn exit(int);
// void *__cdecl calloc(size_t, size_t);
// void __cdecl __noreturn abort();
// int __cdecl _unlock(_DWORD); weak
// int __cdecl _lock(_DWORD); weak
// int __fastcall _initterm(_DWORD, _DWORD); weak
// void __cdecl _cexit();
// int __fastcall _amsg_exit(_DWORD, _DWORD); weak
// int __setusermatherr(void); weak
// int __cdecl __set_app_type(_DWORD); weak
// int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __dllonexit(_DWORD, _DWORD, _DWORD); weak
int _get_invalid_parameter_handler();
signed __int32 __cdecl _set_invalid_parameter_handler(signed __int32 a1);
__int64 __fastcall std::chrono::time_point<std::chrono::_V2::steady_clock,std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>>::time_since_epoch(int a1);
long double __fastcall std::chrono::duration<double,std::ratio<1ll,1ll>>::count(int a1);
__int64 __fastcall std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>::count(int a1);
long double __cdecl std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1ll,1ll>>,long long,std::ratio<1ll,1000000000ll>>(int a1);
long double __cdecl std::chrono::__duration_cast_impl<std::chrono::duration<double,std::ratio<1ll,1ll>>,std::ratio<1ll,1000000000ll>,double,true,false>::__cast<long long,std::ratio<1ll,1000000000ll>>(int a1);
int __stdcall std::chrono::duration<double,std::ratio<1ll,1ll>>::duration<double,void>(int a3);
void __fastcall std::chrono::duration<double,std::ratio<1ll,1ll>>::duration<long long,std::ratio<1ll,1000000000ll>,void>(double *a1, int a2, int a3);
int __fastcall std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>::duration<long long,void>(int a1, int a2, int a3);
__int64 __cdecl std::chrono::operator-<std::chrono::_V2::steady_clock,std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>,std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>>(int a1, int a2);
__int64 __cdecl std::chrono::operator-<long long,std::ratio<1ll,1000000000ll>,long long,std::ratio<1ll,1000000000ll>>(int a1, int a2);
int __cdecl std::min<long long>(int a1, int a2);
int __cdecl main(int argc, const char **argv, const char **envp);
void __noreturn __report_error(char *arg0, ...);
int register_frame_ctor();
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// HANDLE __stdcall GetCurrentProcess();
// DWORD __stdcall GetCurrentProcessId();
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall GetLastError();
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// DWORD __stdcall GetTickCount();
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// void __stdcall Sleep(DWORD dwMilliseconds);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// DWORD __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, DWORD dwLength);
// _onexit_t __cdecl __onexit(_onexit_t);

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN __register_frame_info; weak
func_ptr __CTOR_LIST__[] = { (func_ptr)0xFFFFFFFF }; // idb
int __mingw_winmain_nShowCmd = 10; // weak
int (__cdecl *deregister_frame_fn)(_DWORD) = NULL; // weak
int (*p_66104)[43] = &dword_402D54; // weak
int _dowildcard = 4294967295; // weak
int _CRT_MT = 2; // weak
int _MINGW_INSTALL_DEBUG_MATHERR = 4294967295; // idb
int __security_cookie = 3141592654; // weak
int __security_cookie_complement = 1153374641; // weak
struct _EXCEPTION_POINTERS GS_ExceptionPointers = { &GS_ExceptionRecord, &GS_ContextRecord }; // idb
int (__fastcall *__dyn_tls_init_callback)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &__dyn_tls_init; // weak
char *CSWTCH_6[6] =
{
  "Argument domain error (DOMAIN)",
  "Argument singularity (SIGN)",
  "Overflow range error (OVERFLOW)",
  "The result is too small to be represented (UNDERFLOW)",
  "Total loss of significance (TLOSS)",
  "Partial loss of significance (PLOSS)"
}; // weak
int _RUNTIME_PSEUDO_RELOC_LIST__ = 0; // weak
_UNKNOWN _RUNTIME_PSEUDO_RELOC_LIST_END__; // weak
_UNKNOWN unk_4043EB; // weak
_UNKNOWN __EH_FRAME_BEGIN__; // weak
int _bss_start__; // weak
int has_cctor; // weak
int managedapp; // weak
int mainret; // weak
char **envp; // idb
char **argv; // idb
int argc; // idb
_UNKNOWN obj; // weak
__int64 A; // weak
__int64 B; // weak
__int64 C; // weak
int X; // weak
int dword_406054; // weak
__int64 Y; // weak
__int64 ans; // weak
int initialized; // weak
int mingw_initcharmax; // weak
int dword_40612C; // weak
int dword_406138; // weak
int dword_406144; // weak
int GS_ExceptionRecord; // weak
int dword_406364; // weak
int dword_40636C; // weak
int _newmode; // weak
int mingw_initltssuo_force; // weak
int mingw_initltsdyn_force; // weak
int mingw_initltsdrot_force; // weak
int (__cdecl *stUserMathErr)(_DWORD); // weak
int mingw_app_type; // weak
int was_init_67450; // weak
int maxSections; // weak
int the_secs; // weak
int _fmode;
int (__stdcall *__mingw_oldexcpt_handler)(_DWORD); // weak
void *key_dtor_list; // idb
int __mingwthr_cs_init; // weak
struct _RTL_CRITICAL_SECTION __mingwthr_cs; // idb
int bss; // weak
int __mingw_winmain_lpCmdLine; // weak
int __mingw_winmain_hInstance; // weak
HMODULE hmod_libgcc; // idb
int __onexitend; // weak
int __onexitbegin; // weak
int __native_startup_lock; // weak
int __native_startup_state; // weak
// extern _UNKNOWN ___initenv; weak
// extern _UNKNOWN __acmdln; weak
// extern int __fmode;
// extern FILE __iob[];
// extern _DWORD std::cin; weak
// extern _DWORD std::cout; weak
_UNKNOWN __xd_z; // weak


//----- (00401010) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int pre_c_init()
{
  bool v0; // eax@1
  int result; // eax@5
  __int16 v2; // dx@8

  v0 = 0;
  mingw_initltsdrot_force = 1;
  mingw_initltsdyn_force = 1;
  mingw_initltssuo_force = 1;
  mingw_initcharmax = 1;
  if ( v400000 == 23117 && *(_DWORD *)(v40003C + 0x400000) == 17744 )
  {
    v2 = *(_WORD *)(v40003C + 4194328);
    if ( v2 == 267 )
    {
      if ( *(_DWORD *)(v40003C + 4194420) > 0xEu )
        v0 = *(_DWORD *)(v40003C + 4194536) != 0;
    }
    else if ( v2 == 523 && *(_DWORD *)(v40003C + 4194436) > 0xEu )
    {
      v0 = *(_DWORD *)(v40003C + 4194552) != 0;
    }
  }
  managedapp = v0;
  if ( mingw_app_type )
    __set_app_type(2);
  else
    __set_app_type(1);
  __onexitend = _encode_pointer(-1);
  __onexitbegin = __onexitend;
  __fmode = _fmode;
  _setargv();
  if ( _MINGW_INSTALL_DEBUG_MATHERR == 1 )
  {
    __mingw_setusermatherr((int (__cdecl *)(_DWORD))_matherr);
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 401083: write access to const memory at 4071FC has been detected
// 402A1C: using guessed type int __cdecl __set_app_type(_DWORD);
// 406008: using guessed type int managedapp;
// 406074: using guessed type int mingw_initcharmax;
// 4063C4: using guessed type int mingw_initltssuo_force;
// 4063C8: using guessed type int mingw_initltsdyn_force;
// 4063CC: using guessed type int mingw_initltsdrot_force;
// 4063D8: using guessed type int mingw_app_type;
// 406424: using guessed type int __onexitend;
// 406428: using guessed type int __onexitbegin;

//----- (00401130) --------------------------------------------------------
int pre_cpp_init()
{
  _bss_start__ = _newmode;
  return __getmainargs(&argc, &argv, &envp, _dowildcard, &_bss_start__);
}
// 402A24: using guessed type int __cdecl __getmainargs(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 403014: using guessed type int _dowildcard;
// 406000: using guessed type int _bss_start__;
// 4063C0: using guessed type int _newmode;

//----- (00401170) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int __tmainCRTStartup()
{
  char *v0; // edx@1
  int v1; // ecx@1
  void *v2; // esp@1
  void *v3; // esp@1
  unsigned int v4; // eax@1
  signed __int32 v5; // edi@3
  signed __int32 v6; // eax@6
  signed __int32 v7; // ebx@7
  char v8; // cl@14
  char *v9; // eax@14
  char v10; // dl@20
  signed int v11; // eax@30
  int v12; // ebx@33
  size_t v13; // esi@33
  char **v14; // eax@33
  char **v15; // ebx@34
  const char **v16; // edi@34
  const char *v17; // eax@35
  size_t v18; // eax@35
  size_t v19; // esi@35
  char *v20; // eax@35
  char **v21; // eax@36
  int result; // eax@37
  char v23; // [sp-15h] [bp-9Dh]@1
  size_t v24; // [sp+14h] [bp-74h]@34
  char **v25; // [sp+18h] [bp-70h]@33
  char **v26; // [sp+1Ch] [bp-6Ch]@34
  char v27; // [sp+2Ch] [bp-5Ch]@1
  char v28; // [sp+58h] [bp-30h]@30
  unsigned __int16 v29; // [sp+5Ch] [bp-2Ch]@31

  v0 = &v27;
  memset(&v27, 0, 0x44u);
  v1 = 0;
  v2 = alloca(48);
  v3 = alloca(48);
  v4 = (unsigned int)&v23 & 0xFFFFFFF0;
  *(_DWORD *)v4 = -858993460;
  *(_DWORD *)(v4 + 4) = -858993460;
  *(_DWORD *)(v4 + 8) = -858993460;
  *(_DWORD *)(v4 + 12) = -858993460;
  *(_DWORD *)(v4 + 16) = -858993460;
  *(_DWORD *)(v4 + 20) = -858993460;
  *(_DWORD *)(v4 + 24) = -858993460;
  *(_DWORD *)(v4 + 28) = -858993460;
  if ( mingw_app_type )
    GetStartupInfoA((LPSTARTUPINFOA)&v27);
  v5 = *(_DWORD *)(__readfsdword(24) + 4);
  while ( 1 )
  {
    v6 = _InterlockedCompareExchange((volatile signed __int32 *)&__native_startup_lock, v5, 0);
    if ( !v6 )
    {
      v7 = 0;
      if ( __native_startup_state == 1 )
        goto LABEL_42;
      goto LABEL_8;
    }
    if ( v5 == v6 )
      break;
    Sleep(0x3E8u);
  }
  v7 = 1;
  if ( __native_startup_state == 1 )
  {
LABEL_42:
    _amsg_exit(v1, v0);
    if ( __native_startup_state == 1 )
      goto LABEL_43;
LABEL_11:
    if ( v7 )
      goto LABEL_12;
    goto LABEL_44;
  }
LABEL_8:
  if ( __native_startup_state )
  {
    has_cctor = 1;
  }
  else
  {
    __native_startup_state = 1;
    _initterm(v1, v0);
  }
  if ( __native_startup_state != 1 )
    goto LABEL_11;
LABEL_43:
  _initterm(v1, v0);
  __native_startup_state = 2;
  if ( v7 )
    goto LABEL_12;
LABEL_44:
  _InterlockedExchange((volatile signed __int32 *)&__native_startup_lock, v7);
LABEL_12:
  if ( __dyn_tls_init_callback )
    __dyn_tls_init_callback(v1, v0, 0, 2, 0);
  _pei386_runtime_relocator();
  __mingw_oldexcpt_handler = (int (__stdcall *)(_DWORD))SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)_gnu_exception_handler);
  _set_invalid_parameter_handler((signed __int32)__mingw_invalidParameterHandler);
  fpreset();
  v8 = 0;
  __mingw_winmain_hInstance = 0x400000;
  v9 = (char *)__acmdln;
  if ( __acmdln )
  {
    while ( 1 )
    {
      v10 = *v9;
      if ( *v9 <= 32 )
      {
        if ( !v10 || !(v8 & 1) )
        {
          if ( v10 )
          {
            do
              ++v9;
            while ( *v9 && *v9 <= 32 );
          }
          __mingw_winmain_lpCmdLine = (int)v9;
          break;
        }
        v8 = 1;
      }
      else if ( v10 == 34 )
      {
        v8 ^= 1u;
      }
      ++v9;
    }
  }
  if ( mingw_app_type )
  {
    v11 = 10;
    if ( v28 & 1 )
      v11 = v29;
    __mingw_winmain_nShowCmd = v11;
  }
  v12 = argc;
  v13 = 4 * argc + 4;
  v14 = (char **)malloc(v13);
  v25 = v14;
  if ( v12 <= 0 )
  {
    v21 = v25;
  }
  else
  {
    v15 = v14;
    v16 = (const char **)argv;
    v24 = v13 - 4;
    v26 = (char **)((char *)argv + v13 - 4);
    do
    {
      v17 = *v16;
      ++v15;
      ++v16;
      v18 = strlen(v17);
      v19 = v18 + 1;
      v20 = (char *)malloc(v18 + 1);
      *(v15 - 1) = v20;
      memcpy(v20, *(v16 - 1), v19);
    }
    while ( (const char **)v26 != v16 );
    v21 = (char **)((char *)v25 + v24);
  }
  *v21 = 0;
  argv = v25;
  __main();
  ___initenv = envp;
  result = main(argc, (const char **)argv, (const char **)envp);
  mainret = result;
  if ( !managedapp )
    exit(result);
  if ( !has_cctor )
  {
    _cexit();
    result = mainret;
  }
  return result;
}
// 4013CA: write access to const memory at 4071E0 has been detected
// 401000: using guessed type int __mingw_invalidParameterHandler();
// 4029FC: using guessed type int __fastcall _initterm(_DWORD, _DWORD);
// 402A0C: using guessed type int __fastcall _amsg_exit(_DWORD, _DWORD);
// 403000: using guessed type int __mingw_winmain_nShowCmd;
// 404108: using guessed type int (__fastcall *__dyn_tls_init_callback)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 406004: using guessed type int has_cctor;
// 406008: using guessed type int managedapp;
// 40600C: using guessed type int mainret;
// 4063D8: using guessed type int mingw_app_type;
// 4063EC: using guessed type int (__stdcall *__mingw_oldexcpt_handler)(_DWORD);
// 406418: using guessed type int __mingw_winmain_lpCmdLine;
// 40641C: using guessed type int __mingw_winmain_hInstance;
// 40642C: using guessed type int __native_startup_lock;
// 406430: using guessed type int __native_startup_state;

//----- (004014E0) --------------------------------------------------------
int WinMainCRTStartup()
{
  mingw_app_type = 1;
  __security_init_cookie();
  return __tmainCRTStartup();
}
// 4063D8: using guessed type int mingw_app_type;

//----- (00401500) --------------------------------------------------------
int mainCRTStartup()
{
  mingw_app_type = 0;
  __security_init_cookie();
  return __tmainCRTStartup();
}
// 4063D8: using guessed type int mingw_app_type;

//----- (00401520) --------------------------------------------------------
int __gcc_register_frame()
{
  HMODULE v0; // eax@1
  HMODULE v1; // ebx@2
  FARPROC v2; // esi@2

  v0 = GetModuleHandleA("libgcc_s_dw2-1.dll");
  if ( v0 )
  {
    v1 = v0;
    hmod_libgcc = LoadLibraryA("libgcc_s_dw2-1.dll");
    v2 = GetProcAddress(v1, "__register_frame_info");
    deregister_frame_fn = (int (__cdecl *)(_DWORD))GetProcAddress(v1, "__deregister_frame_info");
  }
  else
  {
    deregister_frame_fn = (int (__cdecl *)(_DWORD))__deregister_frame_info;
    v2 = (FARPROC)&__register_frame_info;
  }
  if ( v2 )
    ((void (__cdecl *)(_DWORD, _DWORD))v2)(&__EH_FRAME_BEGIN__, &obj);
  return atexit(__gcc_deregister_frame);
}
// 402958: using guessed type int __deregister_frame_info();
// 403004: using guessed type int (__cdecl *deregister_frame_fn)(_DWORD);

//----- (004015D0) --------------------------------------------------------
void __cdecl __gcc_deregister_frame()
{
  if ( deregister_frame_fn )
    deregister_frame_fn(&__EH_FRAME_BEGIN__);
  if ( hmod_libgcc )
    FreeLibrary(hmod_libgcc);
}
// 403004: using guessed type int (__cdecl *deregister_frame_fn)(_DWORD);

//----- (00401600) --------------------------------------------------------
void __noreturn err()
{
  ;
}

//----- (00401610) --------------------------------------------------------
int VarInput(void)
{
  int v0; // edx@1
  int v1; // eax@1
  int v2; // edx@1
  int v3; // eax@1
  int v4; // edx@1
  int v5; // eax@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // edx@1
  bool v10; // [sp+4h] [bp-14h]@0

  std::ios_base::sync_with_stdio(0, v10);
  std::basic_ios<char,std::char_traits<char>>::tie((_DWORD *)0x4072DC, 0);
  v1 = std::istream::operator>>(&std::cin, v0);
  v3 = std::istream::operator>>(v1, v2);
  v5 = std::istream::operator>>(v3, v4);
  v7 = std::istream::operator>>(v5, v6);
  return std::istream::operator>>(v7, v8);
}
// 401928: using guessed type int __fastcall std::istream::operator>>(_DWORD, _DWORD);
// 407264: using guessed type _DWORD std::cin;

//----- (00401690) --------------------------------------------------------
int ProSolve(void)
{
  signed __int64 v0; // rdi@1
  unsigned __int8 v1; // cf@9
  int v5; // eax@11
  int v6; // ecx@11
  unsigned __int64 v7; // rax@11
  signed __int64 v8; // kr00_8@11
  int v9; // eax@11
  int v10; // ecx@11
  unsigned __int64 v11; // rax@11
  __int64 v14; // [sp+18h] [bp-40h]@1
  __int64 v15; // [sp+20h] [bp-38h]@1
  __int64 v16; // [sp+28h] [bp-30h]@1
  __int64 v17; // [sp+38h] [bp-20h]@11

  v0 = __PAIR__(X, dword_406054);
  v15 = ans;
  v16 = Y;
  v14 = 2 * C;
  if ( (signed int)((unsigned __int64)(A + B) >> 32) >= (signed int)((unsigned __int64)C >> 31)
    && ((signed int)((unsigned __int64)(A + B) >> 32) > (signed int)((unsigned __int64)C >> 31)
     || (signed int)A + (signed int)B > (unsigned int)(2 * C))
    && dword_406054 >= 0
    && (dword_406054 > 0 || X)
    && SHIDWORD(Y) >= 0
    && (SHIDWORD(Y) > 0 || (_DWORD)Y) )
  {
    do
    {
      v1 = __CFADD__(HIDWORD(v0)--, -1);
      LODWORD(v0) = v1 + (_DWORD)v0 - 1;
      --v16;
      v15 += v14;
      if ( !v0 )
      {
        __asm { vmovq   xmm0, [ebp+var_30] }
        X = 0;
        __asm { vmovq   xmm1, [ebp+var_38] }
        dword_406054 = 0;
        __asm
        {
          vmovq   ds:_Y, xmm0
          vmovq   ds:_ans, xmm1
        }
        goto LABEL_11;
      }
    }
    while ( v16 );
    __asm { vmovq   xmm2, [ebp+var_38] }
    X = HIDWORD(v0);
    dword_406054 = v0;
    Y = 0LL;
    __asm { vmovq   ds:_ans, xmm2 }
  }
LABEL_11:
  __asm
  {
    vmovq   xmm3, [ebp+var_40]
    vmovq   [ebp+var_20], xmm3
  }
  v5 = std::min<long long>((int)&A, (int)&v17);
  v6 = *(_DWORD *)(v5 + 4) * HIDWORD(v0) + v0 * *(_DWORD *)v5;
  v7 = *(_DWORD *)v5 * (unsigned __int64)HIDWORD(v0);
  v8 = v15 + __PAIR__(v6 + HIDWORD(v7), (unsigned int)v7);
  ans = v15 + __PAIR__(v6 + HIDWORD(v7), (unsigned int)v7);
  v9 = std::min<long long>((int)&B, (int)&v17);
  v10 = v16 * *(_DWORD *)(v9 + 4) + HIDWORD(v16) * *(_DWORD *)v9;
  v11 = *(_DWORD *)v9 * (unsigned __int64)(unsigned int)v16;
  HIDWORD(v11) += v10;
  ans = v8 + v11;
  return std::ostream::operator<<(&std::cout, HIDWORD(ans), ans);
}
// 401918: using guessed type int __fastcall std::ostream::operator<<(_DWORD, _DWORD, _DWORD);
// 406038: using guessed type __int64 A;
// 406040: using guessed type __int64 B;
// 406048: using guessed type __int64 C;
// 406050: using guessed type int X;
// 406054: using guessed type int dword_406054;
// 406058: using guessed type __int64 Y;
// 406060: using guessed type __int64 ans;
// 407268: using guessed type _DWORD std::cout;

//----- (0040187F) --------------------------------------------------------
void __cdecl __tcf_0()
{
  std::ios_base::Init *v0; // [sp+0h] [bp-8h]@0

  std::ios_base::Init::~Init(v0);
}

//----- (00401891) --------------------------------------------------------
int __cdecl __static_initialization_and_destruction_0(int a1, int a2)
{
  int result; // eax@3
  std::ios_base::Init *v3; // [sp+0h] [bp-18h]@0

  if ( a1 == 1 && a2 == 0xFFFF )
  {
    std::ios_base::Init::Init(v3);
    result = atexit(__tcf_0);
  }
  return result;
}

//----- (004018BF) --------------------------------------------------------
int _GLOBAL__sub_I__Z3errSt16istream_iteratorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEcS3_iE()
{
  return __static_initialization_and_destruction_0(1, 0xFFFF);
}

//----- (004018E0) --------------------------------------------------------
int __usercall std::basic_ios<char,std::char_traits<char>>::tie@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  _DWORD *v2; // ecx@1
  int result; // eax@1

  v2 = a1;
  result = *a1;
  *v2 = a2;
  return result;
}

//----- (00401930) --------------------------------------------------------
_onexit_t __cdecl mingw_onexit(_onexit_t a1)
{
  _onexit_t result; // eax@2
  _onexit_t v2; // ebx@3
  int v3; // [sp+18h] [bp-14h]@3
  int v4; // [sp+1Ch] [bp-10h]@3

  if ( _decode_pointer(__onexitbegin) == -1 )
  {
    result = __onexit(a1);
  }
  else
  {
    _lock(8);
    v3 = _decode_pointer(__onexitbegin);
    v4 = _decode_pointer(__onexitend);
    v2 = (_onexit_t)__dllonexit(a1, &v3, &v4);
    __onexitbegin = _encode_pointer(v3);
    __onexitend = _encode_pointer(v4);
    _unlock(8);
    result = v2;
  }
  return result;
}
// 4029EC: using guessed type int __cdecl _unlock(_DWORD);
// 4029F4: using guessed type int __cdecl _lock(_DWORD);
// 402A2C: using guessed type int __cdecl __dllonexit(_DWORD, _DWORD, _DWORD);
// 406424: using guessed type int __onexitend;
// 406428: using guessed type int __onexitbegin;

//----- (004019F0) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *a1)())
{
  return -(mingw_onexit((_onexit_t)a1) == 0);
}

//----- (00401A10) --------------------------------------------------------
void __cdecl __do_global_dtors()
{
  void (*v0)(void); // eax@1

  v0 = (void (*)(void))(*p_66104)[0];
  if ( (*p_66104)[0] )
  {
    do
    {
      v0();
      v0 = (void (*)(void))(*p_66104)[1];
      p_66104 = (int (*)[43])((char *)p_66104 + 4);
    }
    while ( v0 );
  }
}
// 403008: using guessed type int (*p_66104)[43];

//----- (00401A50) --------------------------------------------------------
int __do_global_ctors()
{
  func_ptr i; // ebx@1

  i = __CTOR_LIST__[0];
  if ( __CTOR_LIST__[0] == (func_ptr)-1 )
  {
    for ( i = 0; __CTOR_LIST__[(signed int)i + 1]; i = (func_ptr)((char *)i + 1) )
      ;
  }
  for ( ; i; i = (func_ptr)((char *)i - 1) )
    __CTOR_LIST__[(signed int)i]();
  return atexit(__do_global_dtors);
}

//----- (00401AA0) --------------------------------------------------------
int __main()
{
  int result; // eax@1

  result = initialized;
  if ( !initialized )
  {
    initialized = 1;
    result = __do_global_ctors();
  }
  return result;
}
// 406070: using guessed type int initialized;

//----- (00401AD0) --------------------------------------------------------
int _setargv()
{
  return 0;
}

//----- (00401AE0) --------------------------------------------------------
signed int __security_init_cookie()
{
  signed int result; // eax@2
  DWORD v1; // ebx@3
  DWORD v2; // ebp@3
  DWORD v3; // edi@3
  DWORD v4; // esi@3
  int v5; // edx@4
  struct _FILETIME SystemTimeAsFileTime; // [sp+10h] [bp-2Ch]@1
  LARGE_INTEGER PerformanceCount; // [sp+18h] [bp-24h]@3

  SystemTimeAsFileTime.dwLowDateTime = 0;
  SystemTimeAsFileTime.dwHighDateTime = 0;
  if ( __security_cookie == -1153374642 )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v1 = SystemTimeAsFileTime.dwHighDateTime ^ SystemTimeAsFileTime.dwLowDateTime;
    v2 = GetCurrentProcessId();
    v3 = GetCurrentThreadId();
    v4 = GetTickCount();
    QueryPerformanceCounter(&PerformanceCount);
    result = v4 ^ v3 ^ v2 ^ PerformanceCount.HighPart ^ v1 ^ PerformanceCount.LowPart;
    if ( result == -1153374642 )
    {
      v5 = 1153374640;
      result = -1153374641;
    }
    else
    {
      v5 = ~result;
    }
    __security_cookie = result;
    __security_cookie_complement = v5;
  }
  else
  {
    result = ~__security_cookie;
    __security_cookie_complement = ~__security_cookie;
  }
  return result;
}
// 403030: using guessed type int __security_cookie_complement;

//----- (00401B90) --------------------------------------------------------
void __cdecl __noreturn __report_gsfailure(int a1)
{
  HANDLE v1; // eax@1
  int retaddr; // [sp+2Ch] [bp+4h]@1

  GS_ExceptionRecord = -1073740791;
  dword_406364 = 1;
  dword_406144 = (int)&retaddr;
  dword_406138 = retaddr;
  dword_40636C = retaddr;
  dword_40612C = a1;
  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(&GS_ExceptionPointers);
  v1 = GetCurrentProcess();
  TerminateProcess(v1, 0xC0000409);
  abort();
}
// 403030: using guessed type int __security_cookie_complement;
// 40612C: using guessed type int dword_40612C;
// 406138: using guessed type int dword_406138;
// 406144: using guessed type int dword_406144;
// 406360: using guessed type int GS_ExceptionRecord;
// 406364: using guessed type int dword_406364;
// 40636C: using guessed type int dword_40636C;

//----- (00401C20) --------------------------------------------------------
signed int __stdcall __dyn_tls_dtor(int a1, unsigned int a2, int a3)
{
  signed int result; // eax@3

  if ( a2 != 3 && a2 )
  {
    result = 1;
  }
  else
  {
    __mingw_TLScallback(a1, a2);
    result = 1;
  }
  return result;
}

//----- (00401C70) --------------------------------------------------------
signed int __stdcall __dyn_tls_init(int a1, int a2, int a3)
{
  signed int result; // eax@5
  void *v4; // ebx@6

  if ( _CRT_MT != 2 )
    _CRT_MT = 2;
  if ( a2 == 2 )
  {
    v4 = &__xd_z;
    if ( &__xd_z == &__xd_z )
      return 1;
    do
    {
      if ( *(_DWORD *)v4 )
        (*(void (**)(void))v4)();
      v4 = (char *)v4 + 4;
    }
    while ( &__xd_z != v4 );
    result = 1;
  }
  else
  {
    if ( a2 != 1 )
      return 1;
    __mingw_TLScallback(a1, 1u);
    result = 1;
  }
  return result;
}
// 40301C: using guessed type int _CRT_MT;

//----- (00401D00) --------------------------------------------------------
int __tlregdtor()
{
  return 0;
}

//----- (00401D10) --------------------------------------------------------
int (__cdecl *__cdecl __mingw_raise_matherr(int a1, int a2, double a3, double a4, double a5))(_DWORD)
{
  int (__cdecl *result)(_DWORD); // eax@1
  int v6; // [sp+10h] [bp-2Ch]@2
  int v7; // [sp+14h] [bp-28h]@2
  double v8; // [sp+18h] [bp-24h]@2
  double v9; // [sp+20h] [bp-1Ch]@2
  double v10; // [sp+28h] [bp-14h]@2

  result = stUserMathErr;
  if ( stUserMathErr )
  {
    v8 = a3;
    v9 = a4;
    v6 = a1;
    v10 = a5;
    v7 = a2;
    result = (int (__cdecl *)(_DWORD))stUserMathErr(&v6);
  }
  return result;
}
// 4063D4: using guessed type int (__cdecl *stUserMathErr)(_DWORD);

//----- (00401D60) --------------------------------------------------------
int __cdecl __mingw_setusermatherr(int (__cdecl *a1)(_DWORD))
{
  stUserMathErr = a1;
  return __setusermatherr();
}
// 402A14: using guessed type int __setusermatherr(void);
// 4063D4: using guessed type int (__cdecl *stUserMathErr)(_DWORD);

//----- (00401D70) --------------------------------------------------------
int __cdecl _matherr(struct _exception *a1)
{
  const char *v1; // ecx@1
  unsigned int v2; // edx@1

  v1 = "Unknown error";
  v2 = a1->type - 1;
  if ( v2 <= 5 )
    v1 = CSWTCH_6[v2];
  fprintf(&__iob[2], "_matherr(): %s in %s(%g, %g)  (retval=%g)\n", v1, a1->name, a1->arg1, a1->arg2, a1->retval);
  return 0;
}
// 404228: using guessed type char *CSWTCH_6[6];

//----- (00401DD0) --------------------------------------------------------
void __cdecl fpreset()
{
  __asm { fninit }
}

//----- (00401DE0) --------------------------------------------------------
int __cdecl _decode_pointer(int a1)
{
  return a1;
}

//----- (00401DF0) --------------------------------------------------------
int __cdecl _encode_pointer(int a1)
{
  return a1;
}

//----- (00401E00) --------------------------------------------------------
unsigned int __usercall mark_section_writable@<eax>(unsigned int result@<eax>)
{
  int v1; // esi@1
  int v2; // ebx@2
  int v3; // edx@2
  unsigned int v4; // ebx@6
  int v5; // edi@6
  int v6; // ebx@7
  int v7; // eax@7
  const void *v8; // eax@7
  int v9; // ebx@12
  PVOID v10; // eax@12
  SIZE_T v11; // edx@12
  DWORD v12; // eax@13
  struct _MEMORY_BASIC_INFORMATION Buffer; // [sp+14h] [bp-28h]@7

  v1 = maxSections;
  if ( maxSections <= 0 )
  {
    v1 = 0;
LABEL_6:
    v4 = result;
    v5 = __mingw_GetSectionForAddress(result);
    if ( !v5 )
      __report_error("Address %p has no image-section", v4);
    v6 = 20 * v1;
    v7 = 20 * v1 + the_secs;
    *(_DWORD *)(v7 + 16) = v5;
    *(_DWORD *)v7 = 0;
    v8 = (const void *)(*(_DWORD *)(v5 + 12) + _GetPEImageBase());
    *(_DWORD *)(the_secs + 20 * v1 + 12) = v8;
    if ( !VirtualQuery(v8, &Buffer, 0x1Cu) )
      __report_error(
        "  VirtualQuery failed for %d bytes at address %p",
        *(_DWORD *)(v5 + 8),
        *(_DWORD *)(the_secs + v6 + 12));
    result = Buffer.Protect;
    if ( (Buffer.Protect - 64) & 0xFFFFFFBF )
    {
      result = (Buffer.Protect - 4) & 0xFFFFFFFB;
      if ( result )
      {
        v9 = the_secs + v6;
        v10 = Buffer.BaseAddress;
        v11 = Buffer.RegionSize;
        *(_DWORD *)(v9 + 4) = Buffer.BaseAddress;
        *(_DWORD *)(v9 + 8) = v11;
        result = VirtualProtect(v10, v11, 0x40u, (PDWORD)v9);
        if ( !result )
        {
          v12 = GetLastError();
          __report_error("  VirtualProtect failed with code 0x%x", v12);
        }
      }
    }
    ++maxSections;
  }
  else
  {
    v2 = 0;
    v3 = the_secs + 12;
    while ( *(_DWORD *)v3 > result || result >= *(_DWORD *)(*(_DWORD *)(v3 + 4) + 8) + *(_DWORD *)v3 )
    {
      ++v2;
      v3 += 20;
      if ( v2 == maxSections )
        goto LABEL_6;
    }
  }
  return result;
}
// 4063E0: using guessed type int maxSections;
// 4063E4: using guessed type int the_secs;

//----- (00401F50) --------------------------------------------------------
void _pei386_runtime_relocator()
{
  int v0; // ebx@1
  int v1; // eax@3
  void *v2; // esp@3
  void *v3; // esp@3
  unsigned int v4; // ecx@6
  unsigned int v5; // edx@8
  int v6; // ebx@8
  int v7; // edi@10
  int v8; // esi@10
  char v9; // zf@10
  int v10; // ebx@11
  int v11; // eax@13
  unsigned int v12; // esi@20
  int v13; // ebx@22
  int v14; // ecx@22
  unsigned int *v15; // edx@22
  unsigned int v16; // eax@22
  int *v17; // edi@22
  int v18; // ebx@27
  int v19; // ebx@29
  unsigned int v20; // ecx@32
  int v21; // ebx@34
  int v22; // ebx@35
  int v23; // [sp+14h] [bp-34h]@21
  int v24; // [sp+18h] [bp-30h]@8
  int v25; // [sp+18h] [bp-30h]@27
  unsigned int v26; // [sp+1Ch] [bp-2Ch]@3
  DWORD flOldProtect; // [sp+2Ch] [bp-1Ch]@14

  v0 = was_init_67450;
  if ( was_init_67450 )
    return;
  was_init_67450 = 1;
  v1 = 16 * ((unsigned int)(20 * __mingw_GetSectionCount() + 30) >> 4);
  v2 = alloca(v1);
  maxSections = 0;
  v3 = alloca(v1);
  the_secs = ((unsigned int)&v26 + 3) & 0xFFFFFFF0;
  if ( &_RUNTIME_PSEUDO_RELOC_LIST_END__ - (_UNKNOWN *)&_RUNTIME_PSEUDO_RELOC_LIST__ <= 7 )
    return;
  if ( &_RUNTIME_PSEUDO_RELOC_LIST_END__ - (_UNKNOWN *)&_RUNTIME_PSEUDO_RELOC_LIST__ <= 11 )
  {
    v4 = (unsigned int)&_RUNTIME_PSEUDO_RELOC_LIST__;
    if ( _RUNTIME_PSEUDO_RELOC_LIST__ || *(&_RUNTIME_PSEUDO_RELOC_LIST__ + 1) )
      goto LABEL_7;
  }
  else
  {
    if ( _RUNTIME_PSEUDO_RELOC_LIST__ )
    {
      v4 = (unsigned int)&_RUNTIME_PSEUDO_RELOC_LIST__;
LABEL_7:
      if ( v4 >= (unsigned int)&_RUNTIME_PSEUDO_RELOC_LIST_END__ )
        return;
      v24 = v0;
      v5 = v4;
      v6 = v4 + 8;
      v26 = v4 + 8 * (((unsigned int)&unk_4043EB + -v4 - 8) >> 3) + 8;
      while ( 1 )
      {
        v7 = *(_DWORD *)(v5 + 4);
        v8 = *(_DWORD *)v5 + *(_DWORD *)(v7 + 0x400000);
        mark_section_writable(v7 + 0x400000);
        v9 = v6 == v26;
        *(_DWORD *)(v7 + 0x400000) = v8;
        v5 = v6;
        if ( v9 )
          break;
        v6 += 8;
      }
      v10 = v24;
      goto LABEL_12;
    }
    v4 = (unsigned int)&_RUNTIME_PSEUDO_RELOC_LIST__;
  }
  if ( *(_DWORD *)(v4 + 8) != 1 )
    __report_error("  Unknown pseudo relocation protocol version %d.\n", *(_DWORD *)(v4 + 8));
  v12 = v4 + 12;
  if ( v4 + 12 < (unsigned int)&_RUNTIME_PSEUDO_RELOC_LIST_END__ )
  {
    v23 = v0;
    do
    {
      v13 = *(_BYTE *)(v12 + 8);
      v14 = *(_DWORD *)(v12 + 4);
      v15 = (unsigned int *)(*(_DWORD *)v12 + 0x400000);
      v16 = *v15;
      v17 = (int *)(v14 + 0x400000);
      v26 = *v15;
      if ( v13 == 16 )
      {
        v18 = *(_WORD *)(v14 + 0x400000);
        v25 = v14;
        if ( *(_WORD *)(v14 + 0x400000) < 0 )
          v18 |= 0xFFFF0000;
        v19 = v26 + v18 - (_DWORD)v15;
        mark_section_writable(v14 + 0x400000);
        *(_WORD *)(v25 + 0x400000) = v19;
      }
      else if ( v13 == 32 )
      {
        v22 = *v17 + v26 - (_DWORD)v15;
        mark_section_writable(v14 + 0x400000);
        *v17 = v22;
      }
      else
      {
        if ( v13 != 8 )
          __report_error("  Unknown pseudo relocation bit size %d.\n", v13);
        v20 = *(_BYTE *)v17;
        if ( *(_BYTE *)v17 < 0 )
          v20 = *(_BYTE *)v17 | 0xFFFFFF00;
        v21 = v20 - (_DWORD)v15 + v16;
        mark_section_writable((unsigned int)v17);
        *(_BYTE *)v17 = v21;
      }
      v12 += 12;
    }
    while ( v12 < (unsigned int)&_RUNTIME_PSEUDO_RELOC_LIST_END__ );
    v10 = v23;
LABEL_12:
    if ( maxSections > 0 )
    {
      do
      {
        v11 = the_secs + 20 * v10;
        if ( *(_DWORD *)v11 )
          VirtualProtect(*(LPVOID *)(v11 + 4), *(_DWORD *)(v11 + 8), *(_DWORD *)v11, &flOldProtect);
        ++v10;
      }
      while ( v10 < maxSections );
    }
  }
}
// 4043A8: using guessed type int _RUNTIME_PSEUDO_RELOC_LIST__;
// 4063DC: using guessed type int was_init_67450;
// 4063E0: using guessed type int maxSections;
// 4063E4: using guessed type int the_secs;

//----- (004021D0) --------------------------------------------------------
int __stdcall _gnu_exception_handler(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  DWORD v1; // eax@1
  void (__cdecl *v2)(int); // eax@4
  int result; // eax@6
  void (__cdecl *v4)(int); // eax@10
  void (__cdecl *v5)(int); // eax@17

  v1 = ExceptionInfo->ExceptionRecord->ExceptionCode;
  if ( v1 > 0xC0000091 )
  {
    if ( v1 == -1073741676 )
    {
      v4 = signal(8, 0);
      if ( v4 == (void (__cdecl *)(int))1 )
      {
        signal(8, (void (__cdecl *)(int))1);
        return -1;
      }
LABEL_11:
      if ( v4 )
      {
        v4(8);
        return -1;
      }
      goto LABEL_12;
    }
    if ( v1 == -1073741674 )
      goto LABEL_17;
    if ( v1 != -1073741677 )
      goto LABEL_12;
LABEL_10:
    v4 = signal(8, 0);
    if ( v4 == (void (__cdecl *)(int))1 )
    {
      signal(8, (void (__cdecl *)(int))1);
      fpreset();
      return -1;
    }
    goto LABEL_11;
  }
  if ( v1 >= 0xC000008D )
    goto LABEL_10;
  if ( v1 != -1073741819 )
  {
    if ( v1 != -1073741795 )
      goto LABEL_12;
LABEL_17:
    v5 = signal(4, 0);
    if ( v5 == (void (__cdecl *)(int))1 )
    {
      signal(4, (void (__cdecl *)(int))1);
      return -1;
    }
    if ( v5 )
    {
      v5(4);
      return -1;
    }
    goto LABEL_12;
  }
  v2 = signal(11, 0);
  if ( v2 == (void (__cdecl *)(int))1 )
  {
    signal(11, (void (__cdecl *)(int))1);
    return -1;
  }
  if ( v2 )
  {
    v2(11);
    return -1;
  }
LABEL_12:
  if ( __mingw_oldexcpt_handler )
    result = __mingw_oldexcpt_handler(ExceptionInfo);
  else
    result = 0;
  return result;
}
// 4063EC: using guessed type int (__stdcall *__mingw_oldexcpt_handler)(_DWORD);

//----- (00402370) --------------------------------------------------------
void __mingwthr_run_key_dtors_part_0()
{
  DWORD *v0; // ebx@1
  LPVOID v1; // esi@2

  EnterCriticalSection(&__mingwthr_cs);
  v0 = (DWORD *)key_dtor_list;
  if ( key_dtor_list )
  {
    do
    {
      v1 = TlsGetValue(*v0);
      if ( !GetLastError() && v1 )
        ((void (__cdecl *)(LPVOID))v0[1])(v1);
      v0 = (DWORD *)v0[2];
    }
    while ( v0 );
  }
  LeaveCriticalSection(&__mingwthr_cs);
}

//----- (004023E0) --------------------------------------------------------
signed int __cdecl ___w64_mingwthr_add_key_dtor(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v4; // eax@3
  void *v5; // ebx@3
  void *v6; // eax@4

  v2 = 0;
  if ( !__mingwthr_cs_init )
    return v2;
  v4 = calloc(1u, 0xCu);
  v5 = v4;
  if ( !v4 )
    return -1;
  *v4 = a1;
  v4[1] = a2;
  EnterCriticalSection(&__mingwthr_cs);
  v6 = key_dtor_list;
  key_dtor_list = v5;
  *((_DWORD *)v5 + 2) = v6;
  LeaveCriticalSection(&__mingwthr_cs);
  return 0;
}
// 4063F4: using guessed type int __mingwthr_cs_init;

//----- (00402470) --------------------------------------------------------
int __cdecl ___w64_mingwthr_remove_key_dtor(int a1)
{
  int result; // eax@2
  _DWORD *v2; // edx@3
  void *v3; // eax@5

  if ( __mingwthr_cs_init )
  {
    EnterCriticalSection(&__mingwthr_cs);
    v2 = key_dtor_list;
    if ( key_dtor_list )
    {
      if ( a1 == *(_DWORD *)key_dtor_list )
      {
        key_dtor_list = (void *)*((_DWORD *)key_dtor_list + 2);
        v3 = v2;
LABEL_11:
        free(v3);
      }
      else
      {
        while ( 1 )
        {
          v3 = (void *)v2[2];
          if ( !v3 )
            break;
          if ( *(_DWORD *)v3 == a1 )
          {
            v2[2] = *((_DWORD *)v3 + 2);
            goto LABEL_11;
          }
          v2 = (_DWORD *)v2[2];
        }
      }
    }
    LeaveCriticalSection(&__mingwthr_cs);
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 4063F4: using guessed type int __mingwthr_cs_init;

//----- (00402500) --------------------------------------------------------
signed int __cdecl __mingw_TLScallback(int a1, unsigned int a2)
{
  signed int result; // eax@8
  _DWORD *v3; // eax@12
  _DWORD *v4; // ebx@13

  if ( a2 == 1 )
  {
    if ( !__mingwthr_cs_init )
      InitializeCriticalSection(&__mingwthr_cs);
    __mingwthr_cs_init = 1;
    result = 1;
  }
  else
  {
    if ( a2 < 1 )
    {
      if ( __mingwthr_cs_init )
        __mingwthr_run_key_dtors_part_0();
      if ( __mingwthr_cs_init == 1 )
      {
        v3 = key_dtor_list;
        if ( key_dtor_list )
        {
          do
          {
            v4 = (_DWORD *)v3[2];
            free(v3);
            v3 = v4;
          }
          while ( v4 );
        }
        key_dtor_list = 0;
        __mingwthr_cs_init = 0;
        DeleteCriticalSection(&__mingwthr_cs);
      }
    }
    else if ( a2 == 2 )
    {
      fpreset();
    }
    else if ( a2 == 3 )
    {
      if ( __mingwthr_cs_init )
        __mingwthr_run_key_dtors_part_0();
    }
    result = 1;
  }
  return result;
}
// 4063F4: using guessed type int __mingwthr_cs_init;

//----- (004025E0) --------------------------------------------------------
bool __usercall _ValidateImageBase_part_0@<eax>(int a1@<eax>)
{
  int v1; // eax@1
  bool result; // eax@2

  v1 = *(_DWORD *)(a1 + 60) + a1;
  if ( *(_DWORD *)v1 == 17744 )
    result = *(_WORD *)(v1 + 24) == 267;
  else
    result = 0;
  return result;
}

//----- (00402600) --------------------------------------------------------
bool __cdecl _ValidateImageBase(_WORD *a1)
{
  bool result; // eax@2

  if ( *a1 == 23117 )
    result = _ValidateImageBase_part_0((int)a1);
  else
    result = 0;
  return result;
}

//----- (00402620) --------------------------------------------------------
int __cdecl _FindPESection(int a1, unsigned int a2)
{
  int v2; // edx@1
  int v3; // esi@1
  int result; // eax@1
  int v5; // ecx@2
  unsigned int v6; // edx@3

  v2 = *(_DWORD *)(a1 + 60) + a1;
  v3 = *(_WORD *)(v2 + 6);
  result = v2 + *(_WORD *)(v2 + 20) + 24;
  if ( *(_WORD *)(v2 + 6) )
  {
    v5 = 0;
    while ( 1 )
    {
      v6 = *(_DWORD *)(result + 12);
      if ( v6 <= a2 && *(_DWORD *)(result + 8) + v6 > a2 )
        break;
      ++v5;
      result += 40;
      if ( v5 == v3 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (00402660) --------------------------------------------------------
const char *__cdecl _FindPESectionByName(char *a1)
{
  int v1; // ebp@4
  const char *v2; // ebx@4
  int v3; // esi@5
  const char *result; // eax@8

  if ( strlen(a1) <= 8
    && v400000 == 23117
    && _ValidateImageBase_part_0(0x400000)
    && (v1 = *(_WORD *)(v40003C + 4194310),
        v2 = (const char *)(v40003C + 0x400000 + *(_WORD *)(v40003C + 4194324) + 24),
        *(_WORD *)(v40003C + 4194310)) )
  {
    v3 = 0;
    while ( strncmp(v2, a1, 8u) )
    {
      ++v3;
      v2 += 40;
      if ( v3 == v1 )
        goto LABEL_9;
    }
    result = v2;
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (004026F0) --------------------------------------------------------
int __cdecl __mingw_GetSectionForAddress(int a1)
{
  unsigned int v1; // ebx@3
  int result; // eax@3
  int v3; // ecx@4
  unsigned int v4; // edx@5

  if ( v400000 == 23117 )
  {
    if ( _ValidateImageBase_part_0(0x400000)
      && (v1 = a1 - 0x400000,
          result = v40003C + 0x400000 + *(_WORD *)(v40003C + 4194324) + 24,
          *(_WORD *)(v40003C + 4194310)) )
    {
      v3 = 0;
      while ( 1 )
      {
        v4 = *(_DWORD *)(result + 12);
        if ( v1 >= v4 && v1 < *(_DWORD *)(result + 8) + v4 )
          break;
        ++v3;
        result += 40;
        if ( v3 == *(_WORD *)(v40003C + 4194310) )
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00402760) --------------------------------------------------------
int __mingw_GetSectionCount()
{
  int v0; // edx@1
  int result; // eax@2

  v0 = 0;
  if ( v400000 == 23117 && _ValidateImageBase_part_0(0x400000) )
    result = *(_WORD *)(v40003C + 4194310);
  else
    result = v0;
  return result;
}

//----- (00402790) --------------------------------------------------------
int _FindPESectionExec()
{
  int v0; // ecx@2
  int result; // eax@3
  int v2; // edx@4

  if ( v400000 == 23117 && _ValidateImageBase_part_0(0x400000) )
  {
    result = v40003C + 0x400000 + *(_WORD *)(v40003C + 4194324) + 24;
    if ( *(_WORD *)(v40003C + 4194310) )
    {
      v2 = 0;
      do
      {
        if ( *(_BYTE *)(result + 39) & 0x20 )
        {
          if ( !v0 )
            return result;
          --v0;
        }
        ++v2;
        result += 40;
      }
      while ( v2 != *(_WORD *)(v40003C + 4194310) );
    }
  }
  return 0;
}

//----- (004027F0) --------------------------------------------------------
signed int _GetPEImageBase()
{
  char v0; // zf@2
  signed int result; // eax@2

  if ( v400000 == 23117 )
  {
    v0 = _ValidateImageBase_part_0(0x400000) == 0;
    result = 0x400000;
    if ( v0 )
      result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00402820) --------------------------------------------------------
unsigned int __cdecl _IsNonwritableInCurrentImage(int a1)
{
  unsigned int result; // eax@1
  unsigned int v2; // ebx@3
  int v3; // eax@3
  int v4; // ecx@4
  unsigned int v5; // edx@5

  result = 0;
  if ( v400000 == 23117 )
  {
    result = _ValidateImageBase_part_0(0x400000);
    if ( result )
    {
      v2 = a1 - 0x400000;
      v3 = v40003C + 0x400000 + *(_WORD *)(v40003C + 4194324) + 24;
      if ( *(_WORD *)(v40003C + 4194310) )
      {
        v4 = 0;
        while ( 1 )
        {
          v5 = *(_DWORD *)(v3 + 12);
          if ( v2 >= v5 && v2 < *(_DWORD *)(v3 + 8) + v5 )
            break;
          ++v4;
          v3 += 40;
          if ( v4 == *(_WORD *)(v40003C + 4194310) )
            goto LABEL_8;
        }
        result = (unsigned int)~*(_DWORD *)(v3 + 36) >> 31;
      }
      else
      {
LABEL_8:
        result = 0;
      }
    }
  }
  return result;
}

//----- (004028A0) --------------------------------------------------------
int __cdecl __mingw_enum_import_library_names(int a1)
{
  int v1; // ebx@1
  unsigned int v2; // edx@3
  int v3; // ecx@4
  int v4; // esi@5
  unsigned int v5; // eax@6
  int v7; // eax@10

  v1 = a1;
  if ( v400000 == 23117 && _ValidateImageBase_part_0(0x400000) )
  {
    v2 = *(_DWORD *)(v40003C + 4194432);
    if ( v2 )
    {
      v3 = v40003C + 0x400000 + *(_WORD *)(v40003C + 4194324) + 24;
      if ( *(_WORD *)(v40003C + 4194310) )
      {
        v4 = 0;
        while ( 1 )
        {
          v5 = *(_DWORD *)(v3 + 12);
          if ( v2 >= v5 && v2 < *(_DWORD *)(v3 + 8) + v5 )
            break;
          ++v4;
          v3 += 40;
          if ( v4 == *(_WORD *)(v40003C + 4194310) )
            return 0;
        }
        v7 = v2 + 0x400000;
        if ( v2 != -4194304 )
        {
          while ( *(_DWORD *)(v7 + 4) || *(_DWORD *)(v7 + 12) )
          {
            if ( v1 <= 0 )
              return *(_DWORD *)(v7 + 12) + 0x400000;
            --v1;
            v7 += 20;
          }
        }
      }
    }
  }
  return 0;
}

//----- (00402A40) --------------------------------------------------------
int _get_invalid_parameter_handler()
{
  return bss;
}
// 406414: using guessed type int bss;

//----- (00402A50) --------------------------------------------------------
signed __int32 __cdecl _set_invalid_parameter_handler(signed __int32 a1)
{
  return _InterlockedExchange((volatile signed __int32 *)&bss, a1);
}
// 406414: using guessed type int bss;

//----- (00402A60) --------------------------------------------------------
__int64 __fastcall std::chrono::time_point<std::chrono::_V2::steady_clock,std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>>::time_since_epoch(int a1)
{
  return *(_QWORD *)a1;
}

//----- (00402A70) --------------------------------------------------------
long double __fastcall std::chrono::duration<double,std::ratio<1ll,1ll>>::count(int a1)
{
  return *(double *)a1;
}

//----- (00402A80) --------------------------------------------------------
__int64 __fastcall std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>::count(int a1)
{
  return *(_QWORD *)a1;
}

//----- (00402A90) --------------------------------------------------------
long double __cdecl std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1ll,1ll>>,long long,std::ratio<1ll,1000000000ll>>(int a1)
{
  return std::chrono::__duration_cast_impl<std::chrono::duration<double,std::ratio<1ll,1ll>>,std::ratio<1ll,1000000000ll>,double,true,false>::__cast<long long,std::ratio<1ll,1000000000ll>>(a1);
}

//----- (00402AA0) --------------------------------------------------------
long double __cdecl std::chrono::__duration_cast_impl<std::chrono::duration<double,std::ratio<1ll,1ll>>,std::ratio<1ll,1000000000ll>,double,true,false>::__cast<long long,std::ratio<1ll,1000000000ll>>(int a1)
{
  double v2; // [sp+20h] [bp-18h]@1
  double v3; // [sp+28h] [bp-10h]@1

  v2 = (long double)std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>::count(a1) * 0.000000001;
  std::chrono::duration<double,std::ratio<1ll,1ll>>::duration<double,void>((int)&v2);
  return v3;
}

//----- (00402AE0) --------------------------------------------------------
int __stdcall std::chrono::duration<double,std::ratio<1ll,1ll>>::duration<double,void>(int a3)
{
  int result; // eax@1

  result = a3;
  __asm
  {
    vmovsd  xmm0, qword ptr [eax]
    vmovsd  qword ptr [ecx], xmm0
  }
  return result;
}

//----- (00402B00) --------------------------------------------------------
void __fastcall std::chrono::duration<double,std::ratio<1ll,1ll>>::duration<long long,std::ratio<1ll,1000000000ll>,void>(double *a1, int a2, int a3)
{
  double *v3; // ebx@1
  double v4; // [sp+18h] [bp-10h]@1

  v3 = a1;
  v4 = std::chrono::duration_cast<std::chrono::duration<double,std::ratio<1ll,1ll>>,long long,std::ratio<1ll,1000000000ll>>(a3);
  *v3 = std::chrono::duration<double,std::ratio<1ll,1ll>>::count((int)&v4);
}

//----- (00402B30) --------------------------------------------------------
int __fastcall std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>::duration<long long,void>(int a1, int a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)a1 = result;
  return result;
}

//----- (00402B50) --------------------------------------------------------
__int64 __cdecl std::chrono::operator-<std::chrono::_V2::steady_clock,std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>,std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>>(int a1, int a2)
{
  __int64 v3; // [sp+10h] [bp-18h]@1
  __int64 v4; // [sp+18h] [bp-10h]@1

  v4 = std::chrono::time_point<std::chrono::_V2::steady_clock,std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>>::time_since_epoch(a2);
  v3 = std::chrono::time_point<std::chrono::_V2::steady_clock,std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>>::time_since_epoch(a1);
  return std::chrono::operator-<long long,std::ratio<1ll,1000000000ll>,long long,std::ratio<1ll,1000000000ll>>(
           (int)&v3,
           (int)&v4);
}

//----- (00402B90) --------------------------------------------------------
__int64 __cdecl std::chrono::operator-<long long,std::ratio<1ll,1000000000ll>,long long,std::ratio<1ll,1000000000ll>>(int a1, int a2)
{
  int v2; // eax@1
  __int64 v3; // kr00_8@1
  int v4; // eax@1
  __int64 v5; // rax@1
  int v7; // [sp+10h] [bp-28h]@1
  int v8; // [sp+14h] [bp-24h]@1
  int v9; // [sp+18h] [bp-20h]@1
  int v10; // [sp+1Ch] [bp-1Ch]@1
  __int64 v11; // [sp+20h] [bp-18h]@1
  __int64 v12; // [sp+28h] [bp-10h]@1

  v2 = *(_DWORD *)a1;
  v8 = *(_DWORD *)(a1 + 4);
  v7 = v2;
  v3 = std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>::count((int)&v7);
  v4 = *(_DWORD *)a2;
  v10 = *(_DWORD *)(a2 + 4);
  v9 = v4;
  v5 = std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>::count((int)&v9);
  v11 = v3 - v5;
  std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>::duration<long long,void>(
    (int)&v12,
    SHIDWORD(v5),
    (int)&v11);
  return v12;
}

//----- (00402BF0) --------------------------------------------------------
int __cdecl std::min<long long>(int a1, int a2)
{
  int result; // eax@1
  int v3; // ebx@1

  result = a1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(a2 + 4) < v3 || *(_DWORD *)(a2 + 4) <= v3 && *(_DWORD *)a2 < *(_DWORD *)a1 )
    result = a2;
  return result;
}

//----- (00402C20) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // edx@1
  std::chrono::_V2::steady_clock *v4; // ST04_4@1
  int v5; // edx@1
  int v6; // ebx@1
  int v7; // edx@1
  double v8; // ST08_8@1
  int v9; // eax@1
  std::chrono::_V2::steady_clock *v11; // [sp-Ch] [bp-34h]@0
  int v12; // [sp+0h] [bp-28h]@1
  int v13; // [sp+4h] [bp-24h]@1
  int v14; // [sp+8h] [bp-20h]@1
  int v15; // [sp+Ch] [bp-1Ch]@1
  __int64 v16; // [sp+10h] [bp-18h]@1
  char v17; // [sp+18h] [bp-10h]@1
  int *v18; // [sp+24h] [bp-4h]@1

  v18 = &argc;
  __main();
  VarInput();
  v12 = std::chrono::_V2::steady_clock::now(v11);
  v13 = v3;
  ProSolve();
  v14 = std::chrono::_V2::steady_clock::now(v4);
  v15 = v5;
  v16 = std::chrono::operator-<std::chrono::_V2::steady_clock,std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>,std::chrono::duration<long long,std::ratio<1ll,1000000000ll>>>(
          (int)&v14,
          (int)&v12);
  v6 = std::operator<<<std::char_traits<char>>(&std::cout);
  std::chrono::duration<double,std::ratio<1ll,1ll>>::duration<long long,std::ratio<1ll,1000000000ll>,void>(
    (double *)&v17,
    v7,
    (int)&v16);
  v8 = std::chrono::duration<double,std::ratio<1ll,1ll>>::count((int)&v17);
  v9 = std::ostream::operator<<(v6);
  std::operator<<<std::char_traits<char>>(v9);
  return 0;
}
// 4018F0: using guessed type int __stdcall std::operator<<<std::char_traits<char>>(_DWORD);
// 401920: using guessed type int __fastcall std::ostream::operator<<(_DWORD);
// 407268: using guessed type _DWORD std::cout;

//----- (00402CD0) --------------------------------------------------------
void __noreturn __report_error(char *a1, ...)
{
  va_list va; // [sp+24h] [bp+8h]@1

  va_start(va, a1);
  fwrite("Mingw-w64 runtime failure:\n", 1u, 0x1Bu, &__iob[2]);
  vfprintf(&__iob[2], a1, va);
  abort();
}

//----- (00402D30) --------------------------------------------------------
int register_frame_ctor()
{
  return __gcc_register_frame();
}

// ALL OK, 64 function(s) have been successfully decompiled
